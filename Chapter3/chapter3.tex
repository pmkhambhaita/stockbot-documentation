%!TEX root = ../thesis.tex

%*******************************************************************************
%****************************** Third Chapter **********************************
%*******************************************************************************
\chapter{Designing the solution}

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=0.5\linewidth]{Images/breakdown1.png}
	\caption{A further breakdown/structure of the pathfinding feature}
\end{figure}

\section{An initial breakdown of my solution}

Due to the complexity of my solution, I have decomposed my problem down into the fundamentals I believe will benefit me when designing a computational approach to this problem. I have broken down my complex solution into the initial layers of my design outline, and written justifications for each decision. See previous page for the chart outlining the basics.

\begin{enumerate}
    \item Features - this is the central part of the program - what will my program be able to do?
    \item Initialisation and Startup - this is how the program will configure itself - what must happen for my program to begin functioning?
    \item Main Libraries - this is how I will achieve the creation of this program - what is required to make my idea a reality?
    \item Abstraction - this is how I will break down the problem into more manageable chunks appropriate for a computational approach - how can I simplify the program and remove anything unnecessary?
\end{enumerate}


\subsection{Features}
This layer outlines the central features that the system offers in order for my client to benefit from this solution. This allows me to tackle each feature at a time, building a functional solution a section at a time.


\begin{itemize}
    \item Stock Checker - check whether an item is available before fetching it.
    \item Shortest Path Algorithm - find the fastest route to pick up all items
    \item GUI - make my solution more user-friendly and interactive
    \item Direct feedback to user - keep the user informed on what is happening, such as what path is being traced, what items are out of stock and so on.
\end{itemize}

See section x.x.x for a detailed explanation of these features, and see the next few pages for a basic outline of a further breakdown.

\newpage

\begin{figure}[!htbp]
	\centering % Center the minipages on the line
	
	\begin{minipage}{0.48\textwidth} % Adjust width as needed (e.g., 0.48\textwidth)
		\centering
		\includegraphics[width=\linewidth]{Images/pfoutline.png} % Use \linewidth to fit the minipage
		\caption{A further breakdown/structure of the pathfinding feature}
		\label{fig:pfoutline} % Optional: Add a label for referencing
	\end{minipage}% % Add % to prevent unwanted space
	\hfill % Add horizontal space between the minipages (flexible)
	% Or use \hspace{<length>} for fixed space, e.g., \hspace{1cm}
	\begin{minipage}{0.48\textwidth} % Adjust width as needed
		\centering
		\includegraphics[width=0.9\linewidth]{Images/scoutline.png} % Adjust width if needed, e.g. 0.9\linewidth
		\caption{A further breakdown/structure of the stock-checking feature}
		\label{fig:scoutline} % Optional: Add a label for referencing
	\end{minipage}
	
	% Optional: Add a main caption for the whole figure setup
	% \caption{Breakdown of Pathfinding and Stock-Checking Features}
	% \label{fig:combined_features}
	
\end{figure}

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=1\linewidth]{Images/guioutline.png}
	\caption{A further breakdown/structure of the GUI}
\end{figure}


\newpage

\subsection{Initialisation and Startup}

This layer details the steps that will be involved in setting up and starting the system. This includes tasks like initialising the grid, ensuring the database exists and contains values, checking the shortest path algorithm, and displaying all elements of the GUI correctly.

\subsubsection{Setup of environment}

One objective is to configure the program initially - setting up the warehouse environment. It should be decomposed into the following:

\begin{itemize}
    \item Defining the rows and columns: As my program is designed to be used in a typical warehouse environment (one that is comprised of a grid structure), the user should input their warehouse specifications in the form of rows and columns.

    \item Initialise the database: Based on the number of rows and columns, an ID should be assigned to each square as an item to serve as a hypothetical product. The initial quantity should be randomised, then modified by the user.

    \item Load the interface: create all elements of the interface ready for user interaction: this should be done quite quickly.

\end{itemize} 

\subsubsection{Graphical User Interface}

Another objective is to create a functioning and responsive GUI with the following characteristics:

\begin{itemize}
    \item Responsive - The interface should be responsive to the user's clicks/presses and should update in an appropriate amount of time (e.g. 750ms) to display new content.

    \item Functional - The interface should allow users to access all features at the press of a button. The GUI will display key elements, including simple buttons to launch any subprogram of the solution such as a query system. It will also be a legend for the meanings of certain aspects of the visualisation of the warehouse, such as red for out-of-stock, green for the path, etc.

    \item Easy to use - The interface should be very simple and accessible to all users. The layout will be designed with simplicity and intuitiveness in mind, using a logical arrangement of buttons and visual elements. Tooltips and a help toolbar will be integrated to help users understand each feature without requiring detailed training.


\end{itemize}

See sections x.x.x for a prospective GUI

\newpage

\subsection{Main Libraries}

This layer lists the underlying software libraries or tools that are used to build the solution; these libraries provide the building blocks for each feature. Some examples of libraries include:
\begin{itemize}
    \item SQLite: This is a database management system that is used to store and manage data. In this case, I will be using it to store the warehouse layout, item IDs and quantities, as well as a boolean/binary property for whether a coordinate is an obstacle or not.
    \item Tkinter: This is Python's de-facto standard GUI package. It is a thin object-oriented layer on top of Tcl/Tk. Tkinter will be used to construct the GUI due to its simplicity and compatibility with Python. I will specifically using the 'grid' display sub-manager to create each aspect of the interface - this is due to the greater control it offers over positioning.
    \item Threading: This library is used to run multiple threads concurrently within a single process. Threads allow for parallel execution of tasks, enabling efficient utilization of system resources and the ability to perform multiple operations simultaneously. In my case, my algorithm is complex, requiring a large amount of processing power; threading allows the algorithm to run efficiently on the device by not restricting all processes like the GUI and database functions to run on a single thread - separating the algorithm will improve performance.
    \item Logging: This is fairly self-explanatory - the logging library is a built-in module used for generating and managing log messages. It provides a flexible framework for tracking events, debugging, and recording errors in a standardized and structured manner. I plan to use this to instrument my code - this will allow users to see exactly what is happening behind the GUI and allows me to target and debug any issues that may arise.

\end{itemize}

\subsection{Abstraction}

This layer outlines how I have simplified the solution down to essential components that need to be implemented - this is because some contextual parts of the solution are not necessary to craft a prototype and solution, as is the nature of abstraction. For example, current implementations use complex database systems to continually update and handle more advanced cases - since my implementation is designed to be scalable for smaller warehouses and businesses, some features can be abstracted, such as constant database updates and more complex elements of the database.


\subsection{Summary/Justifications}

Using the computational methods/principles, I felt it was best to split my solution into these layers, then further into what may be required to implement each section of the solution. By breaking it down like this, I can easily focus my efforts on a single part of my solution and then not have to worry in the future. Especially with OOP, this structure means I can easily diagnose and fix any errors that occur, while still leaving my code maintainable and clear. See the next page for the structure of my solution modelled as a top-down systems diagram and a class diagram so interactions between components are clear.

\newpage


\begin{figure}[!htbp]
	\centering % Center the minipages on the line
	
	\begin{minipage}{0.65\textwidth} % Adjust width - give this one more space
		\centering
		% Adjusted width from 1\linewidth to \linewidth to fit minipage
		\includegraphics[width=\linewidth]{Images/classdiag1.png}
		\caption{A hypothetical structure of my solution as a class diagram}
		\label{fig:classdiag1} % Optional label
	\end{minipage}% % Prevent extra space
	\hfill % Add horizontal space
	\begin{minipage}{0.27\textwidth} % Adjust width - give this one less space
		\centering
		% Adjusted width from 0.3\linewidth to \linewidth to fit minipage
		\includegraphics[width=\linewidth]{Images/top-down-diagram.png}
		\caption{A basic top-down system diagram}
		\label{fig:topdown} % Optional label
	\end{minipage}
	
	% Optional: Add a main caption for the whole figure setup
	% \caption{System Structure Diagrams}
	% \label{fig:structure_diagrams}
	
\end{figure}


\newpage
\section{Algorithm prototyping}

From the design outline, I will break down each section into the following subsections to begin prototyping my solution using a mixture of pseudocode and flowcharts:

\begin{enumerate}
    \item Create the primary shortest path algorithm (BFS).
    \item Build a rudimentary GUI complementing the SPA.
    \item Implement the database operations and the stock checker.
    \item Unify all the algorithms into a single prototype. (separate section)
\end{enumerate}

Once a fundamental program has been established, I will then proceed to do the following:

\begin{enumerate}
    \item Refine the algorithm to improve performance.
    \item Refine the GUI and add a visualisation of the path for ease of use and accessibility.
    \item Add help sections and more sophisticated database operations to improve user experience.
\end{enumerate}

\subsection{Creating the shortest path algorithm - BFS}

A good starting point is the central feature of this program: the shortest path algorithm. As my solution depends on this feature to outperform a human counterpart, it seems like a sensible point to start. I plan to implement a breadth-first search for the initial program, as it offers easy implementation, albeit at the cost of an optimum route - I can refine this later on as I am taking an object-oriented approach; I will separate the program into its respective features and place them in different files and classes, then call the required methods in a central file.

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.35\linewidth]{Images/bfsvdfs.png}
    \caption{- BFS demonstration \cite{bfsimg}}
\end{figure}

\newpage

\subsubsection{BFS Flowchart}

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.56\linewidth]{Flowcharts/BFS2.png}
\end{figure}

\newpage


\subsubsection*{Grid Class}
The Grid class serves as a spatial abstraction layer that encapsulates the environment representation. This separation of concerns follows sound object-oriented principles by isolating the terrain data structure from the pathfinding algorithm. This approach enables independent modification of the environment's implementation without affecting the pathfinding logic, supporting the open-closed principle and enhancing maintainability.

\begin{itemize}
  \item \textbf{initialiseGrid}: Creates the initial grid structure with empty cells.
    \begin{itemize}
      \item \textbf{Justification}: Critical foundation method that establishes the environment's structure. Without proper initialisation, the entire pathfinding process would have no valid space to operate in.
      \item \textbf{Variables}: width: integer, height: integer, grid: 2D array
      \item \textbf{Type Justification}: Integers provide precise dimensional control with minimal memory footprint. The 2D array structure provides O(1) access time to any cell using coordinates.
    \end{itemize}
    
  \item \textbf{isWithinBounds}: See Validation Functions section.
  
  \item \textbf{isObstacle}: See Validation Functions section.
  
  \item \textbf{getNeighbours}: Returns all traversable adjacent cells.
    \begin{itemize}
      \item \textbf{Justification}: Core traversal method that implements the graph connectivity model. By defining neighbours in the cardinal directions, this method establishes the movement rules for the entire pathfinding system.
      \item \textbf{Variables}: x: integer, y: integer, neighbours: array
      \item \textbf{Type Justification}: Integer coordinates allow precise adjacency calculations. The returned array of position pairs provides a clean interface for iteration.
    \end{itemize}
  
  \item \textbf{setObstacle}: Sets a cell's obstacle status.
    \begin{itemize}
      \item \textbf{Justification}: Provides essential mutability to the environment, allowing for dynamic map changes, responsive obstacles, or initial map setup.
      \item \textbf{Variables}: x: integer, y: integer, isObstacle: boolean, grid[y][x]: boolean
      \item \textbf{Type Justification}: Integer coordinates locate the target cell. The boolean parameter explicitly defines the intended state, preventing type coercion issues.
    \end{itemize}
\end{itemize}

\newpage

\subsubsection*{Pathfinder Class}
The Pathfinder class encapsulates the complete BFS algorithm implementation, separating the pathfinding logic from the environmental representation. This design choice promotes modularity and follows the single responsibility principle by focusing solely on path discovery. The class structure allows for straightforward extension to other pathfinding algorithms (such as A* or Dijkstra's) without modifying the Grid class or dependent systems.

\begin{itemize}
  \item \textbf{findPath}: Main BFS implementation to discover path.
    \begin{itemize}
      \item \textbf{Justification}: The algorithmic core that translates the abstract BFS concept into executable code. This method orchestrates the entire search process, managing the queue, tracking visited states, and coordinating the exploration of the search space.
      \item \textbf{Variables}: startX: integer, startY: integer, endX: integer, endY: integer, queue: array, visited: set
      \item \textbf{Type Justification}: Integer coordinates provide precise position specification. Array implementation for the queue ensures FIFO ordering critical to BFS correctness. Set for visited tracking provides O(1) lookup time.
    \end{itemize}
    
  \item \textbf{validatePoints}: See Validation Functions section.
  
  \item \textbf{createNode}: Creates node objects with parent references.
    \begin{itemize}
      \item \textbf{Justification}: Architectural keystone that establishes the parent-child relationships essential for path reconstruction. This method standardises the node structure throughout the algorithm.
      \item \textbf{Variables}: x: integer, y: integer, parent: object or null, node: object
      \item \textbf{Type Justification}: Integer coordinates locate the node in space. The recursive object structure creates a linked list that captures the entire path history.
    \end{itemize}
    
  \item \textbf{buildPath}: Reconstructs the path from goal to start.
    \begin{itemize}
      \item \textbf{Justification}: Translation layer that converts the linked node structure into a usable, ordered path representation. Without this method, the algorithm would find the goal but be unable to report the actual path.
      \item \textbf{Variables}: endNode: object, path: array
      \item \textbf{Type Justification}: Node object with its chain of parent references contains the complete solution information, allowing backward path reconstruction.
    \end{itemize}
    
  \item \textbf{optimisePath}: Potential optimisation of the raw path.
    \begin{itemize}
      \item \textbf{Justification}: Enhancement method that prepares for future expansion. While BFS provides the shortest path in terms of steps, real applications often benefit from smoothing, diagonal shortcuts, or other optimisations.
      \item \textbf{Variables}: path: array, optimisedPath: array
      \item \textbf{Type Justification}: Array of coordinate pairs offers sequential access and modification capabilities needed for path transformation algorithms.
    \end{itemize}
    
  \item \textbf{logError}: Reports pathfinding errors.
    \begin{itemize}
      \item \textbf{Justification}: Diagnostic interface that improves debuggability and user feedback. Instead of silently failing or throwing exceptions, this method provides structured error reporting.
      \item \textbf{Variables}: message: string, errorType: enum
      \item \textbf{Type Justification}: String type provides flexible, human-readable error descriptions. The error type enumeration allows for programmatic handling of different error categories.
    \end{itemize}
\end{itemize}

\subsubsection*{Validation Functions}
Validation functions are critical components that ensure the integrity and correctness of the pathfinding process. They act as gatekeepers that prevent algorithm failure, detect impossible scenarios early, and provide meaningful feedback when errors occur. These functions collectively create a robust system that fails gracefully and provides useful diagnostic information.

\begin{itemize}
  \item \textbf{isWithinBounds} (Grid): Checks if coordinates are within grid boundaries.
    \begin{itemize}
      \item \textbf{Justification}: Fundamental safety mechanism that prevents array index out-of-bounds errors which would crash the application. This method acts as a gatekeeper for all grid operations.
      \item \textbf{Variables}: x: integer, y: integer, width: integer, height: integer
      \item \textbf{Type Justification}: Integer coordinates allow for direct comparison operations against dimensions. Using the same integer type for all spatial values ensures consistent boundary checks.
    \end{itemize}
    
  \item \textbf{isObstacle} (Grid): Determines if a cell contains an obstacle.
    \begin{itemize}
      \item \textbf{Justification}: Essential for path viability assessment. Without obstacle detection, the algorithm would potentially generate invalid paths through impassable terrain.
      \item \textbf{Variables}: x: integer, y: integer, grid[y][x]: boolean
      \item \textbf{Type Justification}: Integer coordinates provide direct access to the specific cell. The boolean value in each grid cell provides an unambiguous obstacle status.
    \end{itemize}
    
  \item \textbf{validatePoints} (Pathfinder): Validates start and end points.
    \begin{itemize}
      \item \textbf{Justification}: Crucial pre-execution safeguard that prevents wasted computation on impossible scenarios. By checking validity upfront, this method fails fast when given invalid inputs.
      \item \textbf{Variables}: startX: integer, startY: integer, endX: integer, endY: integer
      \item \textbf{Type Justification}: Integer coordinates enable direct validation against grid dimensions and obstacle status. Using primitive types simplifies validation logic with standard comparison operators.
    \end{itemize}
\end{itemize}

\subsubsection{Example pseudocode of functions}

\begin{verbatim}
// Class representing the grid environment
class Grid {
    // Properties
    private cells[][]       // 2D array representing the grid
    private width           // Width of the grid
    private height          // Height of the grid
    
    // Constructor
    constructor(width, height) {
        this.width = width
        this.height = height
        this.cells = initialiseGrid(width, height)
    }
    
    // initialise grid with empty cells
    private initialiseGrid(width, height) {
        // Create a grid of specified dimensions
        // Default cells are traversable (not obstacles)
        return new Array(height).fill().map(() => new Array(width).fill(false))
    }
    
    // Check if given coordinates are within grid boundaries
    public isWithinBounds(x, y) {
        return x >= 0 && x < this.width && y >= 0 && y < this.height
    }
    
    // Check if cell at (x,y) is an obstacle
    public isObstacle(x, y) {
        if (!this.isWithinBounds(x, y)) return true
        return this.cells[y][x]
    }
    
    // Set a cell as an obstacle
    public setObstacle(x, y, isObstacle) {
        if (this.isWithinBounds(x, y)) {
            this.cells[y][x] = isObstacle
        }
    }

    
    // Get all neighbours of a given position that are not obstacles
    public getneighbours(x, y) {
        const neighbours = []
        const directions = [
            {dx: 0, dy: -1},  // Up
            {dx: 1, dy: 0},   // Right
            {dx: 0, dy: 1},   // Down
            {dx: -1, dy: 0}   // Left
        ]
        
        for (const dir of directions) {
            const newX = x + dir.dx
            const newY = y + dir.dy
            
            if (!this.isObstacle(newX, newY)) {
                neighbours.push({x: newX, y: newY})
            }
        }
        
        return neighbours
    }
}

// Class implementing the BFS pathfinding algorithm
class Pathfinder {
    // Properties
    private grid            // Reference to the Grid object
    
    // Constructor
    constructor(grid) {
        this.grid = grid
    }
    
    // Find path using BFS
    public findPath(startX, startY, endX, endY) {
        // Validate start and end points
        if (!this.validatePoints(startX, startY, endX, endY)) {
            this.logError("Invalid start or end points")
            return null
        }

        
        // initialise queue, visited array, and nodes
        const queue = []
        const visited = {}
        const startNode = this.createNode(startX, startY, null)
        
        // Enqueue start node and mark as visited
        queue.push(startNode)
        visited[`${startX},${startY}`] = true
        
        // Main BFS loop
        while (queue.length > 0) {
            // Dequeue current node
            const currentNode = queue.shift()
            
            // Check if goal reached
            if (currentNode.x === endX && currentNode.y === endY) {
                return this.buildPath(currentNode)
            }
            
            // Get all neighbours
            const neighbours = this.grid.getneighbours(currentNode.x, currentNode.y)
            
            // Process each neighbour
            for (const neighbour of neighbours) {
                const key = `${neighbour.x},${neighbour.y}`
                
                // Skip if already visited
                if (visited[key]) continue
                
                // Create neighbour node and set parent
                const neighbourNode = this.createNode(
                neighbour.x, neighbour.y, currentNode)
                
                // Enqueue neighbour and mark as visited
                queue.push(neighbourNode)
                visited[key] = true
            }
        }
        // No path found
        this.logError("No path found")
        return null
    }
    // Validate start and end points
    private validatePoints(startX, startY, endX, endY) {
        // Check if points are within grid boundaries
        if (!this.grid.isWithinBounds(startX, startY) ||
        !this.grid.isWithinBounds(endX, endY)) {
            return false
        }
        
        // Check if points are not obstacles
        if (this.grid.isObstacle(startX, startY) || 
        this.grid.isObstacle(endX, endY)) {
            return false
        }
        
        return true
    }
    
    // Create a new node
    private createNode(x, y, parent) {
        return {
            x: x,
            y: y,
            parent: parent
        }
    }
    
    // Build path by traversing parent references
    private buildPath(endNode) {
        const path = []
        let currentNode = endNode
        
        // Traverse from end node to start node
        while (currentNode !== null) {
            path.unshift({x: currentNode.x, y: currentNode.y})
            currentNode = currentNode.parent
        }
    }
    // Log an error message
    private logError(message) {
        console.log("Error: " + message)
    }
}
\end{verbatim}

\newpage

\subsubsection{Class Structure}
The implementation consists of two classes:
\begin{enumerate}
    \item \textbf{Grid Class}: Manages the environment representation and spatial operations
    \item \textbf{Pathfinder Class}: Implements the BFS algorithm for finding the shortest path
\end{enumerate}

These are separated as they deal with 2 different areas of the solution, making debugging easier and making the code more readable, as functions are now grouped as methods under classes.

\subsubsection{Grid Class}
\begin{itemize}
    \item \textbf{Core Properties}:
    \begin{itemize}
        \item \texttt{cells[][]}: A 2D array representing traversable spaces and obstacles
        \item \texttt{width} and \texttt{height}: Define the dimensions of the grid
    \end{itemize}
    \item \textbf{Key Methods}:
    \begin{itemize}
        \item \texttt{isWithinBounds()}: Ensures coordinates remain within grid limits
        \item \texttt{isObstacle()}: Determines if a cell is blocked and cannot be traversed
        \item \texttt{getneighbours()}: Returns all adjacent traversable cells in orthogonal directions (Up, down, left, right)
    \end{itemize}
\end{itemize}

I used a 2D array as it is similar to a grid in most aspects, and is a good abstraction of a warehouse layout, as each element could represent a shelf/area in a warehouse. I passed width \& height as attributes as they are required to calculate start \& end points.

The \verb|isWithinBounds()| and \verb|isObstacle()| methods are used to validate points so that the program does not fail and is robust.

\subsubsection{Pathfinder Class}
\begin{itemize}
    \item \textbf{Core Methods}:
    \begin{itemize}
        \item \texttt{findPath()}: The main method that orchestrates the entire BFS process
        \item Uses a queue to ensure cells are visited in order of increasing distance from start (FIFO)
    \end{itemize}
    \item \textbf{Supporting Methods}:
    \begin{itemize}
        \item \texttt{validatePoints()}: Performs comprehensive validation of start and end coordinates
        \item \texttt{createNode()}: Constructs node objects with parent references for path reconstruction
        \item \texttt{buildPath()}: Reconstructs the complete path by traversing parent references backward
    \end{itemize}
\end{itemize}

The methods in this class are mostly self-explanatory. The \verb|findPath()| method is used to find a path between 2 points. The \verb|validatePoints()| method ensures the points are valid, using the \verb|grid| methods. The \verb|createNode()| and \verb|buildPath()| methods are used to backtrack and construct the actual path.

\newpage

\subsubsection{BFS Implementation Details}
\begin{enumerate}
    \item \textbf{Initialisation Phase}:
    \begin{itemize}
        \item Validates input points to ensure they're within bounds and not obstacles
        \item Sets up the queue with the starting node and marks it as visited
    \end{itemize}
    \item \textbf{Exploration Phase}:
    \begin{itemize}
        \item Processes nodes in breadth-first order (nearest nodes first)
        \item For each node, checks if it's the goal before exploring neighbours
        \item Avoids revisiting cells by maintaining a visited state dictionary
    \end{itemize}
    \item \textbf{Path Reconstruction Phase}:
    \begin{itemize}
        \item When the goal is found, traces back through parent references
        \item Builds the path from start to end in the correct order
    \end{itemize}
\end{enumerate}

\subsubsection{Validation Strategy}
\begin{itemize}
    \item \textbf{Input Validation}: Checks that start and end points are valid before beginning the search
    \item \textbf{Boundary Validation}: Prevents accessing cells outside the grid boundaries
    \item \textbf{Obstacle Validation}: Ensures only traversable cells are considered during pathfinding
    \item \textbf{Duplicate Prevention}: Avoids processing the same cell multiple times
\end{itemize}

\textbf{}\newline This is an example of how the BFS algorithm could be implemented in pseudocode. As my program grows in complexity, I will most likely deviate from this fixed template of classes but still maintain all the features. For example, when adding the A* algorithm, I can extract the validation features and have a single class dedicated to pathfinding operations only, while another class can handle validation.

\newpage

\subsection{Creating the shortest path algorithm - A*}

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=0.55\linewidth]{Flowcharts/basicastar.png}
\end{figure}

\newpage

The A* algorithm is a refinement in my program, a step above BFS in terms of performance. While more complex to implement, it often finds the path faster as it incorporates a heuristic system.

\begin{itemize} \item \textbf{findPath}: Main A* implementation that orchestrates the pathfinding process. \begin{itemize} \item \textbf{Justification}: Serves as the algorithmic controller that coordinates all aspects of the A* search, from initialisation through node exploration to final path construction. The method systematically explores the grid by always selecting the most promising nodes first, ensuring an optimal solution whilst minimising the search space. \item \textbf{Variables}: startX: integer, startY: integer, endX: integer, endY: integer, openList: array, closedList: set \item \textbf{Type Justification}: Integer coordinates provide precise position specification on the grid. The array implementation for openList is straightforward to manipulate, whilst the set data structure for closedList provides efficient lookup for previously explored nodes. \end{itemize}

\item \textbf{createNode}: Constructs node objects with cost values and parent references. \begin{itemize} \item \textbf{Justification}: Standardises the node structure throughout the algorithm and encapsulates the creation of the node object that must track multiple cost values along with position and parentage. Centralising this construction ensures consistency across all node instances. \item \textbf{Variables}: x: integer, y: integer, parent: object or null, gCost: integer, hCost: integer, fCost: integer \item \textbf{Type Justification}: Integer coordinates identify spatial position on the grid. Integer cost values enable mathematical operations for comparative pathfinding whilst avoiding floating-point precision issues. The parent reference creates a linked structure essential for path reconstruction. \end{itemize}

\item \textbf{calculateHeuristic}: Estimates the distance from a node to the goal. \begin{itemize} \item \textbf{Justification}: Provides the crucial admissible heuristic function that gives A* its efficiency advantage over algorithms like Dijkstra's. For orthogonal movement, the Manhattan distance perfectly estimates the minimum possible cost to reach the goal without overestimation, guiding exploration towards the target. \item \textbf{Variables}: x: integer, y: integer, endX: integer, endY: integer \item \textbf{Type Justification}: Integer coordinates allow for precise Manhattan distance calculation, which is the sum of horizontal and vertical distances, matching exactly the movement constraints of our orthogonal-only system. \end{itemize}

\item \textbf{getBestNode}: Finds the node with the lowest f-cost in the open list. \begin{itemize} \item \textbf{Justification}: This method implements the greedy selection aspect of A* by ensuring that the most promising nodes are explored first. This prioritisation is fundamental to the algorithm's efficiency and optimality guarantees. \item \textbf{Variables}: openList: array, bestNode: object \item \textbf{Type Justification}: The array structure allows for iteration through all candidate nodes, whilst the node object provides access to the cost values needed for comparison. The tie-breaking mechanism using h-cost biases exploration toward the goal when f-costs are equal. \end{itemize}

\item \textbf{getOrthogonalNeighbours}: Returns valid adjacent nodes in the four cardinal directions. \begin{itemize} \item \textbf{Justification}: Implements the graph connectivity model for a grid with orthogonal-only movement. By limiting movement to the four cardinal directions, this method enforces the movement constraints of our simplified pathfinding system. \item \textbf{Variables}: x: integer, y: integer, directions: array, neighbours: array \item \textbf{Type Justification}: Integer coordinates enable precise adjacency calculations. The array of direction vectors provides a clean way to represent and iterate through the four cardinal directions, whilst the resulting neighbours array offers a standard format for the main algorithm to process. \end{itemize}

\item \textbf{buildPath}: Reconstructs the path from goal to start using node parentage. \begin{itemize} \item \textbf{Justification}: Transforms the linked structure of parent references into a usable, sequential path representation. This backward traversal efficiently constructs the optimal path once the goal is reached, without requiring separate bookkeeping during the search phase. \item \textbf{Variables}: endNode: object, path: array, currentNode: object \item \textbf{Type Justification}: The node object contains the complete solution through its parent chain. The resulting array provides a clean, ordered representation of waypoints that can be directly used by path-following systems. \end{itemize} \end{itemize}

\subsubsection*{Validation Functions}

These are identical to BFS validation.

\subsubsection{Example pseudocode for A*}

\begin{verbatim}
class AStarPathfinder:
    # Class variables
    grid: Grid            # Reference to Grid class for terrain information
    openList: Array       # Nodes to be evaluated, manually sorted by fCost
    closedList: Set       # Nodes already evaluated
    
    # Constructor
    function constructor(grid):
        this.grid = grid
    
    # Main pathfinding method
    function findPath(startX, startY, endX, endY):
        # Validate inputs
        if not this.validatePoints(startX, startY, endX, endY):
            this.logError("Invalid start or end point")
            return null
        
        # Initialise data structures
        this.openList = []
        this.closedList = new Set()
        
        # Create and add start node
        startNode = this.createNode(startX, startY, null)
        startNode.gCost = 0
        startNode.hCost = this.calculateHeuristic(startX, startY, endX, endY)
        startNode.fCost = startNode.gCost + startNode.hCost
        this.openList.push(startNode)
        
        # Main loop
        while this.openList.length > 0:
            # Get node with lowest fCost
            currentNode = this.getBestNode()
            
            # Check if goal reached
            if currentNode.x == endX and currentNode.y == endY:
                return this.buildPath(currentNode)
            
            # Remove current from open list and add to closed list
            this.openList.splice(this.openList.indexOf(currentNode), 1)
            this.closedList.add(currentNode.x + "," + currentNode.y)
            
            # Process all neighbours (only orthogonal: up, right, down, left)
            neighbours = this.getOrthogonalNeighbours(currentNode.x, currentNode.y)
            
            for each neighbour in neighbours:
                neighbourKey = neighbour.x + "," + neighbour.y
                
                # Skip nodes in closed list
                if this.closedList.has(neighbourKey):
                    continue
                
                # Each step costs 1 unit in this simplified version
                tentativeGCost = currentNode.gCost + 1
                
                # Check if this node is already in the open list
                existingNode = null
                for each node in this.openList:
                    if node.x == neighbour.x and node.y == neighbour.y:
                        existingNode = node
                        break
                
                if not existingNode:
                    # New node, add to open list
                    neighbourNode = this.createNode(
                    neighbour.x, neighbour.y, currentNode
                    )
                    neighbourNode.gCost = tentativeGCost
                    neighbourNode.hCost = this.calculateHeuristic(
                    neighbour.x, neighbour.y, endX, endY
                    )
                    neighbourNode.fCost = neighbourNode.gCost + neighbourNode.hCost
                    this.openList.push(neighbourNode)
                elif tentativeGCost < existingNode.gCost:
                    # Better path found, update existing node
                    existingNode.gCost = tentativeGCost
                    existingNode.fCost = tentativeGCost + existingNode.hCost
                    existingNode.parent = currentNode
                }
        }
        
        # No path found
        this.logError("No path exists between start and end points")
        return null
    
    # Create a node object with cost values
    function createNode(x, y, parent):
        return {
            x: x,
            y: y,
            gCost: 0,     # Cost from start to this node
            hCost: 0,     # Manhattan distance from this node to goal
            fCost: 0,     # Total cost (g + h)
            parent: parent # Reference to parent node for path reconstruction
        }
    
    # Calculate Manhattan distance from node to goal
    function calculateHeuristic(x, y, endX, endY):
        # Manhattan distance (absolute difference in x plus absolute difference in y)
        return abs(x - endX) + abs(y - endY)
    
    # Find node with lowest fCost in the open list
    function getBestNode():
        bestNode = this.openList[0]
        
        for each node in this.openList:
            if node.fCost < bestNode.fCost:
                bestNode = node
            # Tie-breaker: prefer nodes closer to the goal
            elif node.fCost == bestNode.fCost and node.hCost < bestNode.hCost:
                bestNode = node
        
        return bestNode
    
    # Get orthogonal neighbouring positions (up, right, down, left)
    function getOrthogonalNeighbours(x, y):
        neighbours = []
        
        # The four orthogonal directions
        directions = [
            {x: 0, y: -1},  # Up
            {x: 1, y: 0},   # Right
            {x: 0, y: 1},   # Down
            {x: -1, y: 0}   # Left
        ]
        
        for each dir in directions:
            newX = x + dir.x
            newY = y + dir.y
            
            # Check if position is valid (within bounds and not an obstacle)
            if this.grid.isWithinBounds(newX, newY) and not this.grid.isObstacle(newX, newY):
                neighbours.push({x: newX, y: newY})
        
        return neighbours
    
    # Reconstruct path from goal node to start node
    function buildPath(endNode):
        path = []
        currentNode = endNode
        
        # Traverse parent chain from end to start
        while currentNode:
            path.unshift([currentNode.x, currentNode.y])  # Add to front
            currentNode = currentNode.parent
        
        return path
    
    # Validate start and end points
    function validatePoints(startX, startY, endX, endY):
        # Check if points are within grid bounds
        if not this.grid.isWithinBounds(startX, startY) or not
        this.grid.isWithinBounds(endX, endY):
        
            return false
        
        # Check if points are not obstacles
        if this.grid.isObstacle(startX, startY) or this.grid.isObstacle(endX, endY):
            return false
        
        return true
    
    # Log errors for diagnostics
    function logError(message):
        console.log("AStarPathfinder Error: " + message)
\end{verbatim}

\newpage

\subsection{GUI Logic}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\linewidth]{Flowcharts/guiflowchart.png}
	
\end{figure}

\newpage

\subsection{Database operations}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.91\linewidth]{Flowcharts/dbops1.png}

\end{figure}

\newpage

\subsubsection{Database validation}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1\linewidth]{Flowcharts/dbinit.png}
\end{figure}

\newpage

\subsubsection{Database query}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.4\linewidth]{Flowcharts/dbquery.png}
\end{figure}

\newpage

\subsubsection{Database update}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.9\linewidth]{Flowcharts/dbwrite.png}
\end{figure}

\newpage

\subsection{Configuration}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.4\linewidth]{Flowcharts/config1.png}

\end{figure}

\newpage

\subsection{JSON import/export}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\linewidth]{Flowcharts/json.png}

\end{figure}

\newpage

\subsection{Possible refinements}

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=0.4\linewidth]{Flowcharts/optimisedastar.png}
\end{figure}

\newpage
\section{Usability}

On the subject of GUIs, what rules should a GUI actually follow to be optimal for the end user? The guidelines below are a subset of the ones that form the guides of both the Google and the Adobe design team, and hence appropriate due to both their success and accessibility. \textsuperscript{\cite{design1, design2}}

\subsection{Guidelines}
\begin{itemize}
\item \textbf{Visibility of system status:} Users should always be informed of system operations with easy to understand and highly visible status displayed on the screen within a reasonable amount of time.

\item \textbf{Consistency and standards:} Interface designers should ensure that both the graphic elements and terminology are maintained across similar platforms. For example, an icon that represents one category or concept should not represent a different concept when used on a different screen.

\item \textbf{Error prevention:} Whenever possible, design systems so that potential errors are kept to a minimum. Users do not like being called upon to detect and remedy problems, which may on occasion be beyond their level of expertise. Eliminating or flagging actions that may result in errors are two possible means of achieving error prevention.

\item \textbf{Recognition rather than recall:} Minimise cognitive load by maintaining task-relevant information within the display while users explore the interface. Human attention is limited and we are only capable of maintaining around five items in our short-term memory at one time. Due to the limitations of short-term memory, designers should ensure users can simply employ recognition instead of recalling information across parts of the dialogue. Recognising something is always easier than recall because recognition involves perceiving cues that help us reach into our vast memory and allowing relevant information to surface. For example, we often find the format of multiple choice questions easier than short answer questions on a test because it only requires us to recognise the answer rather than recall it from our memory.

\item \textbf{Aesthetic and minimalist design:} Keep clutter to a minimum. All unnecessary information competes for the user's limited attentional resources, which could inhibit user's memory retrieval of relevant information. Therefore, the display must be reduced to only the necessary components for the current tasks, whilst providing clearly visible and unambiguous means of navigating to other content.

\end{itemize}

\newpage

\subsection{Configuration Screen Analysis}
\begin{figure}[!htbp]
    \centering
    \includegraphics[width=1\linewidth]{Images/InitGUI.jpg}
    \caption{- A hypothetical configuration window prior to running the main program.}
\end{figure}

\newpage



\subsubsection{Guideline alignment:}


    \begin{itemize}
        \item Visibility of System Status
        \begin{itemize}
            \item Clear numeric displays for rows/columns
            \item Plus/minus controls provide immediate feedback
            \item "Continue" button shows clear next step
    
        \end{itemize}
    \end{itemize}
    
    \begin{itemize}
        \item Error Prevention
        \begin{itemize}
            \item Bounded input fields prevent invalid grid sizes
            \item Plus/minus buttons prevent text input errors
            \item Single "Continue" path reduces navigation errors
        \end{itemize}
    \end{itemize}
    
    \begin{itemize}
        \item Recognition vs Recall
    
        \begin{itemize}
            \item Labelled "Rows" and "Columns" fields
            \item Simple numeric input reduces cognitive load
            \item Clear action button labelled "Continue"
        \end{itemize}
    \end{itemize}
    
    
    \begin{itemize}
        \item Aesthetic/Minimalist
    
        \begin{itemize}
            \item Only essential grid setup controls
            \item Clean layout without distracting elements
            \item Logical grouping of related controls
        \end{itemize}
\end{itemize}



\begin{itemize}
    \item Consistency

    \begin{itemize}
        \item Uniform input field styling
        \item Consistent plus/minus button placement
        \item Standard window controls
    \end{itemize}
\end{itemize}


\subsubsection{Usability Analysis:}

The numeric input fields with increment/decrement controls are an optimal solution for grid dimension entry, as there are many variants of warehouse that can be constructed via row and column definition - this allows for faster input of the desired warehouse dimensions. \newline The interface's spatial organisation leverages natural reading patterns and mental models by arranging elements in a logical left-to-right, top-to-bottom flow that correlates with the final grid structure. \newline The centrally positioned continue button serves as a clear visual endpoint, while the minimalist two-field design effectively mitigates a cluttered and hard-to-navigate interface that would otherwise arise if this and the main program was incorporated as one window.

\newpage

\subsection{Main Screen Analysis}

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=1\linewidth]{Images/GUI.jpg}
    \caption{- The main window of StockBot}
\end{figure}

\newpage




\subsubsection{Guideline alignment:}

    \begin{itemize}
        \item Visibility of System Status
        \begin{itemize}
            \item Legend shows current grid state meanings
            \item Total path distance display
            \item Clear input field for points
    
        \end{itemize}
    \end{itemize}
    
    \begin{itemize}
        \item Error Prevention
        \begin{itemize}
            \item Explicit format guidance ("comma-separated")
            \item Legend prevents colour interpretation errors
            \item Clear button labels prevent navigation mistakes
        \end{itemize}
    \end{itemize}
    
    \begin{itemize}
        \item Recognition vs Recall
    
        \begin{itemize}
            \item Complete legend eliminates colour code memorisation
            \item Input format shown directly above field
            \item Descriptive button labels
        \end{itemize}
    \end{itemize}
    
    
    \begin{itemize}
        \item Aesthetic/Minimalist
    
        \begin{itemize}
            \item Logical grouping of controls
            \item Clean separation of input/visualisation areas
            \item Essential information only
        \end{itemize}
\end{itemize}

This interface is consistent for the same reasons as the configuration screen.

\subsubsection{Usability Analysis}
The implementation of a text entry field for input is the best choice as it offers flexibility and choice to the user, while remaining as simple as possible. While I did consider multiple drop-down menus, one for the number of points and the others for items, I dismissed the idea on the fact that a large warehouse would lead to a very cluttered UI. This design choice also allows for easier parsing, as the entire entry can be taken at once rather than extraction from each drop-down menu. \newline The interface architecture has a clear visual hierarchy that guide users through complex tasks while maintaining accessibility to all functions. Primary functions are placed prominently (the entry boxes), while secondary functions are placed at the bottom, attracting less attention. \newline
While I initially did not want to include a legend, adding one would benefit the user; it eliminates cognitive overhead from trying to decipher which colours represent what.

\newpage

\subsection{Grid Visualisation}

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.6\linewidth]{gridvisual.jpg}
    \caption{- An example visualisation of the path.}
\end{figure}

\section{Unifying the algorithms}

While the algorithms are complete, the solution has not yet been unified into a functional app; as I have used OOP principles in the code, it will be much easier to create a working prototype. See section x.x.x for the benefits OOP provides. The goal is to combine the shortest path algorithms (SPA), the graphical user interface (GUI), and the database management system into a cohesive application structured around these three core features. I have broken down the unification process into the module breakdown, the role of each module, the key functions and the interactions between modules.

\subsection{Key modules breakdown}

\subsubsection{GUI}
    
This serves as the main entry point for the program. It will manage user input, visualisation, and overall coordination of the application. When necessary, the program will call methods or functions from the SPA and Database modules for computation and data management respectively.

\begin{itemize}
    \item Primary Role: Acts as the main control system and interface between the user and the computational/backend modules.
    \item Key Functions:
        \begin{itemize}
            \item Input Collection: Accepts user inputs like setting obstacles, defining waypoints, and initiating pathfinding.
            \item Visualisation: Displays the grid and highlights paths, obstacles, and waypoints for the user.
            \item Interaction with SPA: Passes grid configurations and waypoints to the SPA module to compute the shortest path.
            \item Interaction with Database: Calls Database to save or load grid states, configurations, or paths.
        \end{itemize}
    \item Effect of unification: \newline
    The GUI acts as a bridge between the user and the underlying logic. It passes the data it collects (like grid configurations or waypoints) to SPA for computations and calls Database for storage tasks. All modules are coordinated through the GUI, making it the central orchestrator.
\end{itemize}


\subsubsection{SPA}
This contains the core algorithms for computing the shortest path. It contains logic for handling grid data, waypoints and pathfinding. In the program, it will act as a processing unit, receiving data from the GUI, performing computations, and returning results.

\begin{itemize}
    \item Primary Role: Implements and executes the algorithms that compute the shortest path on a grid.
    \item Key Functions:
        \begin{itemize}
            \item Algorithm Logic: Encapsulates shortest path algorithms.
            \item Data Handling: Accepts grid configuration and waypoints from GUI and processes them to compute the desired path.
            \item Result Output: Returns the computed path to the GUI for visualisation.
        \end{itemize}
    \item Effect of unification: \newline
        SPA is isolated from the GUI and database logic, focusing purely on computation. It accepts data from GUI and processes it using the appropriate algorithm. By keeping the logic separate, the module remains reusable and scalable, allowing future algorithms to be added without modifying the GUI or database.
\end{itemize}



\subsubsection{Database}
This will provides data persistence by saving and loading grid configurations, waypoints, and paths. It will ensures the program can maintain state across sessions, enabling users to resume from where they left off.

\begin{itemize}
    \item Primary Role: Stock management - ensuring stock is present and if not, to skip over the item.
    \item Key Functions:
        \begin{itemize}
            \item Data Integrity: Ensures that saved data remains consistent and valid.
            \item Stock assignment: Allows for items to be assigned to positions in the warehouse
            \item Stock verification: Verifies that stock exists and if not, to remove the item from queue.
        \end{itemize}
    \item Effect of unification: \newline
        Database connects with GUI to store or retrieve data as requested by the user. This separation of concerns allows the GUI to focus on interaction and visualization, while the database handles storage operations independently.
\end{itemize}

These are just the key features that are integral to my solution. I have also included some quality-of-life features that I feel the stakeholders would benefit from, which I will include if time permits.

\newpage

\subsection{A unified implementation}

\begin{figure}[htbp!]
    \centering
    \includegraphics[width=0.7\linewidth]{Flowcharts/Unified.png}

\end{figure}

\newpage

\section{Test data}

\subsection{Standard data}

I will be using the following data as a boilerplate environment for post-development in addition to the test data below. These are the parameters I will set for generic testing for the stakeholders. They will test it as they see fit and report back with any final feedback. I will not be providing them with exact data as I wish to simulate a real environment and hence test this software in a less controlled manner; this is why this data is more ambiguous.

\begin{itemize}
	\item Grid layout: 15 x 15 default, user discretion to change
	\item Random database generation
	\item Point selection varying between 2 and 224, using a random number generator
	\item Number of points varying between 1 and 25, using a random number generator
\end{itemize}

\subsection{During development}

These tests will be performed during development. The test IDs are in the format TA.B.C where A is the sprint number, B is the iteration number and C is the test number. T.x.F tests are the tests that will be performed under the guidance and view of the stakeholders, while T.x.x tests will be used to test each iteration.

\begin{longtable}{|p{0.08\textwidth}|p{0.2\textwidth}|p{0.3\textwidth}|p{0.3\textwidth}|} % 4 columns with specified widths
	\caption{Iterative Tests During Sprint Ada} \label{tab:sprint_ada_tests_lt_rev} \\
	\hline
	\textbf{Test ID} & \textbf{Test Description} & \textbf{Expected Behaviour} & \textbf{Justification} \\
	\hline
	\endfirsthead
	
	\multicolumn{4}{c}%
	{{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\
	\hline
	\textbf{Test ID} & \textbf{Test Description} & \textbf{Expected Behaviour} & \textbf{Justification} \\
	\hline
	\endhead
	
	\hline \multicolumn{4}{r}{{Continued on next page}} \\
	\endfoot
	
	\hline
	\endlastfoot
	
	% Sprint Tests (Stakeholder Focus - T1.F) - from Table 3.1
	T1.F.1 & Path found using input points & The system should calculate and display a valid path connecting the start, intermediate (if any), and end points. & Verifies core pathfinding functionality with valid inputs, as recommended by stakeholders. \\
	\hline
	T1.F.2 & Input invalid points (letters, numbers and symbols) & The system should reject the input and display a clear error message indicating invalid format or characters. & Ensures robust input validation preventing errors from unexpected data types, as recommended by stakeholders. \\
	\hline
	T1.F.3 & Input no points & The system should calculate and display the direct path from the start point to the end point. & Tests handling of edge case where no intermediate stops are requested, as recommended by stakeholders. \\
	\hline
	% Iteration Tests (Developer Focus - T1.1, T1.2) - from Table 3.2 / Table 4.1, 4.2
	T1.1.1 & Input 0,0 and 9,9 (Assuming 10x10 grid, terminal) & System should calculate and output the direct path between start (0,0) and end (9,9). & Verifies core BFS functionality between default start/end nodes, the heart of the program. \\
	\hline
	T1.1.2 & Input 1,2 and 5,7 (Terminal/Internal) & System calculates and outputs the shortest path between (1,2) and (5,7). & Tests BFS between arbitrary valid points, core program functionality. \\
	\hline
	T1.1.3 & Input -1,-1 and 4,8 (Terminal/Internal) & System should detect (-1,-1) is out of bounds and return an error or None. & Tests boundary validation for negative coordinates to ensure robustness. \\
	\hline
	T1.1.4 & Input 0,1 and 10,10 (Assuming 10x10 grid, terminal) & System should detect (10,10) is out of bounds and return an error or None. & Tests boundary validation for coordinates exceeding grid dimensions to ensure robustness. \\
	\hline
	T1.2.1 & No intermediate points selected (Terminal/Internal) & System should calculate the path directly from the pre-defined start to the pre-defined end node. & Checks validation measures for the SPA, specifically handling the base case (no intermediate points). \\
	\hline
	T1.2.2 & Input 3,4 and 5,8 (Terminal/Internal) & System calculates path from start to (3,4), then from (3,4) to (5,8), then from (5,8) to end. & Verifies the logic for connecting path segments between multiple intermediate points. \\
	\hline
	T1.2.3 & Input -1,-1 (Terminal/Internal) & System validation should reject this point as out of bounds. & Checks validation for negative inputs in multi-point context. \\
	\hline
	T1.2.4 & Input one valid and one non-valid point (Terminal/Internal) & System should reject the invalid point and either error out or calculate path using only the valid point. & Checks validation for partially invalid input lists. \\
	\hline
	T1.2.5 & Input 5 invalid points (Terminal/Internal) & System should reject all points and indicate no valid path can be formed or return an error. & Checks validation against multiple invalid inputs. \\
	\hline
	T1.2.6 & Input valid points and verify it is the shortest path (Terminal/Internal) & The output path length should match the expected shortest path length calculated manually or by known BFS properties. & Confirms the core algorithm (BFS) is correctly finding the optimal path (in terms of steps) and validates path length calculation. \\
	\hline
\end{longtable}

\begin{longtable}{|p{0.08\textwidth}|p{0.2\textwidth}|p{0.3\textwidth}|p{0.3\textwidth}|}
	\caption{Iterative Tests During Sprint Berners-Lee (GUI Introduction)} \label{tab:sprint_bernerslee_tests_lt_rev} \\
	\hline
	\textbf{Test ID} & \textbf{Test Description} & \textbf{Expected Behaviour} & \textbf{Justification} \\
	\hline
	\endfirsthead
	\multicolumn{4}{c}{{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\ \hline
	\textbf{Test ID} & \textbf{Test Description} & \textbf{Expected Behaviour} & \textbf{Justification} \\ \hline \endhead
	\hline \multicolumn{4}{r}{{Continued on next page}} \\ \endfoot \hline \endlastfoot
	
	% Sprint Tests (Stakeholder Focus - T2.F) - from Table 3.1 / Final Testing Table p.102
	T2.F.1 & Enter "2,3" and click Add Point & Point (2,3) or equivalent itemID added, entry cleared, confirmation shown. & Tests main success path for adding points via GUI, essential for stakeholder use. \\
	\hline
	T2.F.2 & Enter "2,2" then "5,5", click Find Path & Grid shows path (0,0) → (2,2) → (5,5) → (9,9) with visualisation. & Tests main success path for finding path with multiple points via GUI. \\
	\hline
	T2.F.3 & Enter "abc" and click Add Point & Error message about invalid format. & Targets key validation rule critical for usability and data integrity. \\
	\hline
	T2.F.4 & Enter "10,10" and click Add Point (Assuming 10x10 grid) & Error message about out of bounds. & Targets key validation rule critical for usability and data integrity. \\
	\hline
	T2.F.5 & Enter "0,0" and click Add Point (Assuming 10x10 grid) & Error about using start point. & Targets key validation rule critical for usability and data integrity. \\
	\hline
	T2.F.6 & Add "2,2" and "3,3", click Clear & All points cleared, confirmation message. & Tests the interface reset functionality. \\
	\hline
	T2.F.7 & Click Find Path with no points & Error about no points added. & Covers edge case handling (boundary test). \\
	\hline
	T2.F.8 & Enter "1,1", "8,1", "8,8", "1,8" sequence & Complete path visiting all points shown. & Covers main success path variations. \\
	\hline
	% Iteration Tests (Developer Focus - T2.1, T2.2) - Table 4.3 & 4.4
	T2.1.1 & Run script (GUI Introduction) & Only GUI appears, no residual terminal interface. & Verifies correct startup sequence and removal of terminal execution. \\
	\hline
	T2.1.2 & Launch GUI & Window appears with input field, text area, Add/Find/Clear buttons. & Checks basic GUI layout and widget creation. \\
	\hline
	T2.1.3 & Add valid point (e.g., 3,4) & Point added, confirmation in output text. & Tests basic point addition functionality. \\
	\hline
	T2.1.4 & Add multiple valid points & Points added sequentially to internal list, confirmation shown. & Ensures multiple points can be added. \\
	\hline
	T2.1.5 & Click Find Path with points & Grid visualisation (text-based initially) appears in output text area. & Verifies integration with pathfinding and visualisation output redirection. \\
	\hline
	T2.1.6 & Click Clear & Points list cleared, output area cleared/reset message shown. & Tests GUI clear functionality. \\
	\hline
	T2.1.7 & Add start point (0,0) & Expected: Rejected. Actual (Iter 1): Added. & Tests validation (initially failing) for reserved start/end points. \\
	\hline
	T2.1.8 & Add out-of-bounds point (-1,5) & Expected: Rejected with error in GUI. Actual (Iter 1): Rejected, logged to console. & Tests boundary validation and error message display (initially only console). \\
	\hline
	T2.2.1 & Add start point (0,0) & Rejected, error message in GUI ("Cannot use start/end point"). & Verifies improved validation prevents adding start point via GUI. \\
	\hline
	T2.2.2 & Add end point (9,9) & Rejected, error message in GUI ("Cannot use start/end point"). & Verifies improved validation prevents adding end point via GUI. \\
	\hline
	T2.2.3 & Add out-of-bounds point (-1,5) & Rejected, error message in GUI ("Coordinates ... out of bounds"). & Verifies boundary validation with error message displayed in GUI. \\
	\hline
	T2.2.4 & Enter invalid format (’abc’) & Rejected, error message in GUI ("Invalid format..."). & Verifies input format validation with error message displayed in GUI. \\
	\hline
	T2.2.5 & Click Find Path with no points & Error message in GUI ("No intermediate points added..."). & Verifies handling of empty point list scenario in GUI. \\
	\hline
	T2.2.6 & Perform valid path operation & Path visualisation in GUI, log entries in stockbot\_log.txt. & Confirms successful pathfinding integrates with GUI display and file logging. \\
	\hline
\end{longtable}


\begin{longtable}{|p{0.08\textwidth}|p{0.2\textwidth}|p{0.3\textwidth}|p{0.3\textwidth}|}
	\caption{Iterative Tests During Sprint Cerf} \label{tab:sprint_cerf_tests_lt_rev} \\
	\hline
	\textbf{Test ID} & \textbf{Test Description} & \textbf{Expected Behaviour} & \textbf{Justification} \\
	\hline
	\endfirsthead
	\multicolumn{4}{c}{{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\ \hline
	\textbf{Test ID} & \textbf{Test Description} & \textbf{Expected Behaviour} & \textbf{Justification} \\ \hline \endhead
	\hline \multicolumn{4}{r}{{Continued on next page}} \\ \endfoot \hline \endlastfoot
	
	% Iteration Tests (Developer Focus - T3.1A to T3.2D) - Tables 4.6 to 4.12
	T3.1A.1 & Find path with several points (potentially slow) & GUI remains responsive, "Processing..." message shown, path appears correctly after delay. & Tests responsiveness improvement from threading, verifying threading implementation worth. \\
	\hline
	T3.1A.2 & Click Find Path twice quickly & Second click shows "Already processing..." message or is ignored. Only one path result appears. & Ensures locking mechanism prevents issues with concurrent requests due to threading. \\
	\hline
	T3.1B.1 & Launch, enter 15x15, click OK & Config closes, main GUI uses 15x15 size. & Verifies config window works as expected and passes dimensions correctly. \\
	\hline
	T3.1B.2 & Enter invalid config (0, text, >50) in Spinboxes, click OK & Error messagebox shown, config window stays open. & Confirms config window handles invalid user input correctly. \\
	\hline
	T3.1C.1 & Enter itemID 15 (10x10 grid), Add Point & "Added position 15" message shown in output. & Tests adding points using the new 1-N itemID system. \\
	\hline
	T3.1C.2 & Add itemIDs 15, 99. Find Path. & Path sequence displayed as "1 → ... → 15 → ... → 99 → ... → 100". & Verifies path output uses the 1-N itemID system correctly. \\
	\hline
	T3.1C.3 & Enter invalid itemID (0 or 101 on 10x10 grid) & GUI shows error "Position X out of range (1-100)". & Tests range validation for the 1-N itemID input. \\
	\hline
	T3.1C.4 & Start with 15x15 config. Check range label. & Label shows "Enter position (1-225)". & Confirms the GUI range label updates based on configured grid size. \\
	\hline
	T3.2A.1 & Delete inventory.db. Run code that instantiates InventoryDB. Run again. & inventory.db created. No errors on second run. & Verifies database initialisation and `CREATE TABLE IF NOT EXISTS` logic. \\
	\hline
	T3.2A.2 & Inspect inventory.db schema using DB browser. & `items` table exists with correct columns/types/constraints. & Confirms correct database schema creation, setting up for data interaction. \\
	\hline
	T3.2B.1 & Run python database.py. Check console output and inspect DB. & Output shows correct quantities/positions for all items. DB contains expected data. & Verifies `populaterandomdata` and getter methods work correctly in isolation. \\
	\hline
	T3.2B.2 & Test validate\_item\_id (e.g., via \_\_main\_\_) with valid, invalid range, non-existent IDs. & Returns True for valid ID, raises ValueError for others. & Ensures core database validation methods handle errors appropriately. \\
	\hline
	T3.2B.3 & Test update\_quantity with valid/invalid quantity values (e.g., -1, "abc"). & Updates correctly for valid int >= 0, raises ValueError/TypeError otherwise. & Ensures core database validation methods handle errors appropriately. \\
	\hline
	T3.2C.1 & Enter valid itemID, click Query Stock & Correct stock \& position shown. INFO/DEBUG log in file. & Verifies new GUI feature for database interaction works correctly and integrates with logging. \\
	\hline
	T3.2C.2 & Enter valid itemID, click Update, enter 50, confirm. Query again. & Update success msg. INFO log. Query shows 50. & Verifies new GUI feature for database interaction works correctly and confirms DB update. \\
	\hline
	T3.2C.3 & Enter invalid ID/qty for Query/Update. & GUI error shown. ERROR log created. & Verifies new GUI features handle user input errors correctly. \\
	\hline
	T3.2C.4 & Config 15x10 grid. Query/Update itemID 150. & Works correctly. Invalid point handled gracefully. & Ensures database operations respect the configured grid size boundaries. \\
	\hline
	T3.2D.1 & Find itemID X with stock=1. Add X. Find Path. Query X. & Point added ("Stock: 1"). Path found. Query shows Stock=0. & Verifies core stock decrementing logic after successful path. \\
	\hline
	T3.2D.2 & Try Add Point X again (now stock=0). & Warning "Skipping...Out of stock" shown. Point not added to path list. & Verifies core stock checking requirement: preventing adding zero-stock items. \\
	\hline
	T3.2D.3 & Add points Y, Z (stock>0). Find Path. Check stock Y, Z via Query. & Path found. Query shows stock Y--, Z-- (decremented). & Confirms stock decrement applies correctly to multiple items on path. \\
	\hline
	% Sprint Tests (Final - T3.F) - Table 4.13
	T3.F.1 & Config 15x15. Add valid, in-stock itemID 113, add 200. Find path. & GUI responsive, path found/displayed using itemIDs 1 → ... → 113 → ... → 200 → ... → 225. Stock for 113, 200 decremented by 1. & End-to-end test combining config, threading, indexing, pathfinding, and stock decrement. \\
	\hline
	T3.F.2 & Config 10x10. Query itemID 1. Update stock to 0. Query again. & Query shows initial stock > 0. Update confirms. Second query shows 0. & Verifies manual stock update and query functionality. \\
	\hline
	T3.F.3 & With stock=0 for itemID 1, try Add Point itemID 1. & Error "Skipping position 1 - Out of stock" shown. Point *not* added to path list. & Confirms core requirement: cannot add zero-stock items to path. \\
	\hline
	T3.F.4 & Test config screen validation (text, 0, >50). & Error messageboxes shown, prevents confirmation. & Final check on configuration input validation robustness. \\
	\hline
\end{longtable}


\begin{longtable}{|p{0.08\textwidth}|p{0.2\textwidth}|p{0.3\textwidth}|p{0.3\textwidth}|}
	\caption{Iterative Tests During Sprint Dijkstra} \label{tab:sprint_dijkstra_tests_lt_rev} \\
	\hline
	\textbf{Test ID} & \textbf{Test Description} & \textbf{Expected Behaviour} & \textbf{Justification} \\
	\hline
	\endfirsthead
	\multicolumn{4}{c}{{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\ \hline
	\textbf{Test ID} & \textbf{Test Description} & \textbf{Expected Behaviour} & \textbf{Justification} \\ \hline \endhead
	\hline \multicolumn{4}{r}{{Continued on next page}} \\ \endfoot \hline \endlastfoot
	
	% Iteration Tests (Developer Focus - T4.1) - Table 4.15
	T4.1.1 & Find simple path multiple times (post-revert) & Path found correctly each time. No crashes. & Verifies stability after removing threading, ensuring the revert was successful. \\
	\hline
	T4.1.2 & Find complex path (longer calculation) (post-revert) & GUI freezes temporarily, path found correctly. No crashes. & Confirms return to synchronous behaviour and basic stability under load. \\
	\hline
	T4.1.3 & Run other GUI actions (Query/Update Stock, Clear) after pathfinding (post-revert) & All actions work correctly without async errors. & Ensures other GUI functions remain stable and unaffected by the revert. \\
	\hline
\end{longtable}

\begin{longtable}{|p{0.08\textwidth}|p{0.2\textwidth}|p{0.3\textwidth}|p{0.3\textwidth}|}
	\caption{Iterative Tests During Sprint Engelbart} \label{tab:sprint_engelbart_tests_lt_rev} \\
	\hline
	\textbf{Test ID} & \textbf{Test Description} & \textbf{Expected Behaviour} & \textbf{Justification} \\
	\hline
	\endfirsthead
	\multicolumn{4}{c}{{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\ \hline
	\textbf{Test ID} & \textbf{Test Description} & \textbf{Expected Behaviour} & \textbf{Justification} \\ \hline \endhead
	\hline \multicolumn{4}{r}{{Continued on next page}} \\ \endfoot \hline \endlastfoot
	
	% Iteration Tests (Developer Focus - T5.1 to T5.3) - Tables 4.17 to 4.19
	T5.1.1 & Click "Show Grid" & Separate window opens with canvas \& grid/numbers. & Tests basic creation and display of the dedicated visualisation window. \\
	\hline
	T5.1.2 & Find Path & Visualisation window updates (basic drawing). & Verifies linking between pathfinding and the new visualiser update mechanism. \\
	\hline
	T5.1.3 & Click Clear All & Expected: Visualisation canvas clears/resets. Actual (Iter 1): Only text box cleared. & Tests integration of Clear All with visualiser (validating fix needed). \\
	\hline
	T5.2.1 & Show Grid, Find Path, Clear, Show. & Viz opens; Path/points coloured; Clears output; Re-shows. & Tests full cycle of visualiser state management (path display, clearing, redraw). \\
	\hline
	T5.2.2 & Find path with low (<2) \& zero stock points. & Viz shows path, low stock points orange, zero stock red. & Verifies correct stock level colour-coding in the graphical visualisation. \\
	\hline
	T5.2.3 & Test viz with large grid (20x20). & Scrollbars appear \& work. Window sized well. & Checks visualiser scaling for larger grids and scrollbar functionality. \\
	\hline
	T5.2.4 & Close Viz window (’X’). Find Path. Show Grid. & No errors. New window opens with correct path/grid. & Tests robustness against user closing/reopening the visualiser window. \\
	\hline
	T5.3.1 & Launch GUI & Simplified layout, 600x500 size. & Confirms UI simplification changes (removing elements) applied correctly. \\
	\hline
	T5.3.2 & Enter "15 99", Find Path (stock ok) & Path "1 → ... → 100" including 15, 99 calculated. & Tests new multi-point space-separated input method for pathfinding. \\
	\hline
	T5.3.3 & Enter "15 abc 99". Find Path. & Error for "abc". Path calc for 15, 99. & Tests validation handling (ignoring invalid parts) within multi-point input parsing. \\
	\hline
	T5.3.4 & Query Stock via button/pop-up. & Correct stock shown. & Verifies stock query using the new dedicated pop-up dialog workflow. \\
	\hline
	T5.3.5 & Update Stock via button/pop-ups. Query. & Update confirmed. Query shows new stock. & Verifies stock update using the new dedicated pop-up dialog workflow. \\
	\hline
	T5.3.6 & Enter only zero-stock points. Find Path. & Warning shown. Direct start → end path calculated. & Tests fallback logic when no valid intermediate points with stock are entered. \\
	\hline
	% Sprint Tests (Final - T5.F) - Table 4.20
	T5.F.1 & Config 15x15. Enter multiple valid points. Find Path. Check Viz. & Path computed. Viz shows path, stock colours correctly. Main GUI simple/clean. & End-to-end validation of refined UI, multi-point input, and visualiser integration. \\
	\hline
	T5.F.2 & Update stock to 0 via pop-up. Find path. Check Viz. & Update works. Viz shows item red (OOS). Path avoids/warns about item. & Validates interaction between manual stock update, pathfinding (stock check), and visualisation. \\
	\hline
	T5.F.3 & Enter only zero-stock points. Find Path. & Warning messages. Direct start → end path computed \& shown on Viz. & Confirms fallback path behaviour and its correct visualisation. \\
	\hline
	T5.F.4 & Test Query/Update pop-ups. Test Clear All. & Pop-ups work. Clear All resets GUI and Viz correctly (OOS markers remain). & Final validation of stock pop-ups and Clear All state management (visualiser persistence). \\
	\hline
\end{longtable}


\begin{longtable}{|p{0.08\textwidth}|p{0.2\textwidth}|p{0.3\textwidth}|p{0.3\textwidth}|}
	\caption{Iterative Tests During Sprint Floyd (Algorithms)} \label{tab:sprint_floyd_tests_lt_rev} \\
	\hline
	\textbf{Test ID} & \textbf{Test Description} & \textbf{Expected Behaviour} & \textbf{Justification} \\
	\hline
	\endfirsthead
	\multicolumn{4}{c}{{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\ \hline
	\textbf{Test ID} & \textbf{Test Description} & \textbf{Expected Behaviour} & \textbf{Justification} \\ \hline \endhead
	\hline \multicolumn{4}{r}{{Continued on next page}} \\ \endfoot \hline \endlastfoot
	
	% Iteration Tests (Developer Focus - T6.1, T6.2) - Tables 4.22 & 4.23
	T6.1.1 & Enter 3+ points, Optimisation OFF. Find Path. & Path found, points visited in the order entered. & Verifies pathfinding works correctly without GA point order optimisation. \\
	\hline
	T6.1.2 & Enter 3+ points, Optimisation ON. Find Path. & Path found, point order potentially changed. Log confirms optimisation ran. Total path length likely shorter. & Confirms GA optimisation runs and potentially improves path length. \\
	\hline
	T6.1.3 & Enter 1-2 points, Optimisation ON. Find Path. & Path found. Log confirms optimisation skipped as unnecessary. & Tests edge case handling for GA (not needed for <2 intermediate points). \\
	\hline
	T6.1.4 & Toggle "Optimize Point Order" via GUI Menu. & Checkbox state updates. Log message confirms optimisation enabled/disabled. & Verifies the GUI toggle for enabling/disabling GA optimisation works. \\
	\hline
	T6.1.5 & Enter >10 points, Optimisation ON. Find Path. & Warning logged about limiting points. Optimisation runs on first 10. Path found. & Checks handling of GA limits (necessary for performance). \\
	\hline
	T6.2.1 & Select BFS via Algorithm menu, Find Path (simple). & Path found using BFS. Log confirms BFS used. & Verifies BFS algorithm selection via GUI and correct execution. \\
	\hline
	T6.2.2 & Select A* via Algorithm menu, Find Path (simple). & Path found using A*. Log confirms A* used. Path length identical to BFS. & Verifies A* selection and correctness (should match BFS on unweighted grid). \\
	\hline
	T6.2.3 & Select A*, find path involving boundary checks. & Path found correctly, A* uses validate\_point for neighbour checks. & Confirms A* correctly uses the unified validation function after refactoring. \\
	\hline
	T6.2.4 & Switch between BFS/A* algorithm selection via menu multiple times. & Selection updates correctly. Correct algorithm called on Find Path (check log). & Tests the GUI mechanism for switching between pathfinding algorithms. \\
	\hline
	% Sprint Tests (Final - T6.F) - Table 4.24
	T6.F.1 & Run complex path (3+ pts), BFS selected, Optimisation OFF. Note length. & Shortest path segments found using BFS. Points visited in order entered. & Baseline test: Verifies BFS path calculation without optimisation. \\
	\hline
	T6.F.2 & Run same path, A* selected, Optimisation OFF. Note length. & Shortest path segments found using A*. Points visited in order entered. Total length matches T6.F.1. & Verifies A* path calculation and compares length to BFS (should be equal). \\
	\hline
	T6.F.3 & Run same path, BFS selected, Optimisation ON. Note length. & Path segments via BFS. Point order potentially changed by GA for shorter total length than T6.F.1. & Tests the combined effect of GA optimisation with BFS path segments. \\
	\hline
	T6.F.4 & Run same path, A* selected, Optimisation ON. Note length. & Path segments via A*. Point order potentially changed by GA. Total length matches T6.F.3 (should be same shortest path). & Tests the combined effect of GA optimisation with A* path segments. \\
	\hline
\end{longtable}

\begin{longtable}{|p{0.08\textwidth}|p{0.2\textwidth}|p{0.3\textwidth}|p{0.3\textwidth}|}
	\caption{Iterative Tests During Sprint Gates (Obstacles)} \label{tab:sprint_gates_tests_lt_rev} \\
	\hline
	\textbf{Test ID} & \textbf{Test Description} & \textbf{Expected Behaviour} & \textbf{Justification} \\
	\hline
	\endfirsthead
	\multicolumn{4}{c}{{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\ \hline
	\textbf{Test ID} & \textbf{Test Description} & \textbf{Expected Behaviour} & \textbf{Justification} \\ \hline \endhead
	\hline \multicolumn{4}{r}{{Continued on next page}} \\ \endfoot \hline \endlastfoot
	
	% Iteration Tests (Developer Focus - T7.1, T7.2) - Tables 4.26 & 4.27
	T7.1.1 & Manually set obstacle in grid state (debug). Run BFS/A*. & Path avoids the set obstacle cell. & Verifies backend algorithms respect obstacle data set internally. \\
	\hline
	T7.1.2 & Manually set obstacle completely blocking path. Run BFS/A*. & Algorithms return None (no path found). & Verifies algorithms correctly handle impossible paths due to obstacles. \\
	\hline
	T7.1.3 & Call validate\_point on an obstacle location. & Function returns False. & Confirms validation function correctly identifies obstacles added to grid state. \\
	\hline
	T7.1.4 & Call validate\_point on a non-obstacle location. & Function returns True. & Confirms validation function passes non-obstacle locations correctly. \\
	\hline
	T7.2.1 & Click Obstacle Mode, enter valid ID, click Toggle. Check Viz. & Obstacle appears on visualiser grid. Confirmation message shown. & Tests GUI interaction for adding an obstacle and verifies visual feedback. \\
	\hline
	T7.2.2 & Add obstacle blocking direct path. Find Path. Check Viz. & Path routes around obstacle. Viz shows obstacle correctly. & Tests integration: obstacle added via GUI is avoided by pathfinding and shown visually. \\
	\hline
	T7.2.3 & Click Obstacle Mode, enter invalid ID (e.g., start/end, text). Click Toggle. & Error messagebox shown. No obstacle added. & Tests validation for obstacle input via the GUI pop-up. \\
	\hline
	T7.2.4 & Add obstacle. Click Obstacle Mode, enter same ID, click Toggle. Check Viz. & Obstacle removed from visualiser grid. Confirmation message shown. & Tests GUI interaction for removing an obstacle and verifies visual feedback. \\
	\hline
	T7.2.5 & Add obstacles. Click Clear All. Show Grid. & Visualiser grid shows no obstacles. & Verifies Clear All correctly resets internal obstacle state and visualisation. \\
	\hline
	% Sprint Tests (Final - T7.F) - Table 4.28
	T7.F.1 & Add obstacle (itemID X). Try add point at X. & Cannot add point, error shown. & Confirms point validation prevents adding locations marked as obstacles. \\
	\hline
	T7.F.2 & Add obstacle (itemID Y) blocking direct path. Find Path (BFS/A*). & Path successfully routes around Y. Viz shows Y obstacle marker. & End-to-end test of adding obstacle via GUI, path avoidance, and visualisation. \\
	\hline
	T7.F.3 & Surround end point with obstacles. Find Path. & "No valid path found" error. & Tests handling of impossible scenarios created by user-placed obstacles. \\
	\hline
	T7.F.4 & Add obstacles. Clear All. Add obstacle at same previous location. Find path. & Obstacles cleared. Can add obstacle again. Path found (if possible). & Verifies obstacle state reset via Clear All and re-addition functionality. \\
	\hline
\end{longtable}

\newpage

\subsection{Post-development}

\begin{longtable}{|p{0.02\textwidth}|p{0.2\textwidth}|p{0.25\textwidth}|p{0.25\textwidth}|p{0.1\textwidth}|}
	\hline
	\textbf{\#} & \textbf{Test} & \textbf{Expected Behaviour} & \textbf{Justification} & \textbf{Test Type} \\
	\hline
	\endhead
	
	1 & Input item 101 in a 10×10 grid via points entry field & Error message: "Point 101 does not exist in current grid configuration" & Tests error handling for out-of-bounds items to ensure the system validates input before attempting path calculation & Erroneous \\
	\hline
	2 & Input "abc" in the points entry field & Error message: "Invalid Input: Please enter valid points" & Validates non-numeric input handling to prevent type errors in the processing logic & Erroneous \\
	\hline
	3 & Configure a 0×5 grid using configuration screen & Error message: "Invalid grid dimensions, rows and columns must be at least 1" & Tests boundary validation for minimum grid size to ensure system prevents invalid configurations & Boundary \\
	\hline
	4 & Configure a 51×50 grid using configuration screen & Error message: "Invalid grid dimensions. Maximum rows allowed is 100" & Tests upper boundary limits for grid configuration to ensure system prevents excessive resource consumption & Boundary \\
	\hline
	5 & Set quantity of ItemID 25 to 0, then attempt to include it in path by entering points "20,25,30" & Point 25 is omitted from pathfinding and an error message is shown & Tests zero-stock validation to ensure the system prevents journeys to zero-inventory locations & Functional \\
	\hline
	6 & Set quantity of ItemID 25 to -5 using update quantity function & Error message: "Invalid quantity. Value must be 0 or positive" & Tests negative value validation to ensure database integrity for stock quantities & Erroneous \\
	\hline
	7 & Set obstacles to completely block all paths between points 1 and 25 in a 5×5 grid, then attempt pathfinding & Error message: "No path found between the given points" within 5 seconds & Verifies system correctly identifies impossible path scenarios and provides appropriate feedback & Functional \\
	\hline
	8 & Enter start or end points (1 or 100) in points field for a 10×10 grid & Error message: "You have inputted a start and/or end point. Please remove it!" & Tests validation logic for preventing the selection of reserved points (start/end) & Functional \\
	\hline
	9 & Enter comma-separated points with trailing space "5 10 15 " & Uses existing points and finds a path & Tests parsing robustness for malformed input to ensure the system handles common input errors & Erroneous \\
	\hline
	10 & Enter a valid path with points "5,10,15" in a 10×10 grid with all items in stock & System calculates and displays optimal path including points 1,5,10,15,100 within 5 seconds & Tests core pathfinding functionality under normal operating conditions & Functional \\
	\hline
	11 & Update quantity of non-existent ItemID 101 in a 10×10 grid & Error message: "Error: ItemID 101 does not exist" & Tests boundary validation for database operations to prevent manipulation of non-existent records & Boundary \\
	\hline
	12 & Query information for ItemID 0 & Error message: "No item found" or "ItemID must be at least 1" & Tests lower boundary validation for item query functionality & Boundary \\
	\hline
	13 & Configure a 1×1 grid (minimum possible size) & System should create grid with single cell, start and end both at position 1 & Tests minimum boundary case for grid configuration to ensure the system handles edge cases & Boundary \\
	\hline
	14 & Configure a 50×50 grid (maximum allowed size) & System should create grid with 2500 cells without freezing or crashing & Tests maximum boundary case for grid configuration to assess system stability under maximum load & Boundary \\
	\hline
	15 & Set all intermediate points to have 0 quantity in a 5×5 grid, then attempt pathfinding & Error message indicating all points are unavailable or out of stock & Tests comprehensive validation when all requested points are invalid & Functional \\
	\hline
	16 & Create a path where points 5,10,15 are visited, then run again after setting point 10 to quantity 0 & Second run should find alternative path excluding point 10 & Tests system adaptation to changing inventory conditions & Functional \\
	\hline
	17 & Save configuration with specific setup to JSON file, then load the same file & System should restore exact grid dimensions, obstacles, and item quantities with 100\% accuracy & Tests data persistence functionality to ensure configurations can be reliably saved and restored & Functional \\
	\hline
	18 & Load a deliberately corrupted JSON configuration file & Error message indicating invalid configuration file, system should maintain previous state & Tests error handling for data integrity issues to prevent system corruption & Erroneous \\
	\hline
	19 & Rapidly click the "Find Path" button 10 times in succession & System should ignore additional clicks while processing, without crashing & Tests UI stability under rapid user interaction to ensure the system handles potential race conditions & Stress \\
	\hline
	20 & Set obstacles in a pattern forcing a very long path ($>$50 steps) in a 10×10 grid & System should calculate correct path navigating all obstacles within reasonable time ($<$10 seconds) & Tests pathfinding algorithm performance in worst-case scenarios & Performance \\
	\hline
	21 & Request path through 20 intermediate points in a 20×20 grid & System should calculate optimal path visiting all points within 10 seconds & Tests algorithm scalability for complex routing scenarios & Performance \\
	\hline
	22 & Enter points with mixed spacing "5, 10,15, 20" & System should correctly parse input and calculate path through points 5,10,15,20 & Tests input parsing flexibility to handle various user input formats & Functional \\
	\hline
	23 & Use obstacle mode to create a complex maze with only one valid orthogonal path, then request pathfinding & System should find the only valid path through maze & Tests path finding in highly constrained environments & Functional \\
	\hline
	24 & Click on a grid cell with quantity 5, verify information displayed & Dialogue should show correct ItemID, row, column, and quantity (5) & Tests item information display functionality & Functional \\
	\hline
	25 & Set ItemID 42 to quantity 0 and verify its visual representation in grid & Cell should be highlighted in red colour in the visualisation & Tests correct visual indication of out-of-stock items & Functional \\
	\hline
	26 & Update quantity of an item to 1, then traverse path through this item & Item should be flagged as below threshold ($<$2) after path completion, with quantity updated to 0 and colour changed to red & Tests low stock detection, flagging and visual indication & Functional \\
	\hline
	27 & Query an item after updating its quantity & Dialogue should show updated quantity value, not original value & Tests database consistency after update operations & Functional \\
	\hline
	28 & Set quantity of an item to maximum 32-bit integer value (2,147,483,647) & System should accept and store this value without errors & Tests handling of extreme values within valid range & Boundary \\
	\hline
	29 & Find path in a 10×10 grid with obstacles placed to create exactly 2 possible orthogonal paths & System should find the shorter of the two possible paths & Tests optimal path selection when multiple valid paths exist & Functional \\
	\hline
	30 & Run pathfinding with valid points "5,10,15" then immediately change grid configuration & Either current operation should complete with original grid or error should indicate configuration changed during operation & Tests system stability during concurrent operations & Functional \\
	\hline
	31 & Export grid visualisation to image file after calculating complex path & Exported image should accurately represent grid with all cells, paths, obstacles and point highlights matching on-screen display & Tests data visualisation consistency between display and export & Functional \\
	\hline
	32 & Create a grid with obstacles in positions that would make start or end points inaccessible & System should detect that no path is possible and display appropriate error message & Tests validation for critical point accessibility & Functional \\
	\hline
	33 & Configure grid with alternating obstacles creating a "checkerboard" pattern & System should correctly calculate path navigating through the pattern using only orthogonal movements & Tests pathfinding in highly constrained but solvable scenarios & Functional \\
	\hline
	34 & Set item quantities for points along a path to exactly 1, then run path twice & First run should succeed with all cells in path, second run should omit previously visited points that now have 0 quantity & Tests stock depletion scenario handling & Functional \\
	\hline
	35 & Configure grid with obstacles along all edges except start and end points & System should calculate path navigating through the internal grid area using only orthogonal movements & Tests boundary obstacle handling & Functional \\
	\hline
	36 & Open visualisation window, close it, then request pathfinding & System should reopen visualisation window and display calculated path correctly & Tests window management and state recovery & Functional \\
	\hline
	37 & Load configuration with large grid (50×50), switch to small grid (5×5), then back to large grid & System should correctly render both grid sizes without display artifacts or sizing issues & Tests UI scaling and flexibility & Functional \\
	\hline
	38 & Leave points entry field blank and click "Find Path" & System should prompt user to enter a point & Tests handling of minimal/empty input & Boundary \\
	\hline
	39 & Verify colour coding in grid visualisation for start point (position 1) & Start point should be highlighted in blue colour & Tests correct visual indication of start point & Functional\\
	\hline
	40 & Verify colour coding in grid visualisation for end point (position 25 in 5×5 grid) & End point should be highlighted in blue colour & Tests correct visual indication of end point & Functional \\
	\hline
	41 & Verify colour coding in grid visualisation for user-specified points (5,10,15) & User points should be highlighted in yellow colour & Tests correct visual indication of user-specified points & Functional \\
	\hline
	42 & Verify colour coding in grid visualisation for calculated path & Path cells should be highlighted in green colour & Tests correct visual indication of calculated path & Functional \\
	\hline
	43 & Verify colour coding in grid visualisation for obstacle cells & Obstacle cells should be highlighted in black colour & Tests correct visual indication of obstacles & Functional \\
	\hline
	44 & Verify colour coding in grid visualisation for out-of-stock cells & Out-of-stock cells should be highlighted in red for 0, orange for near 0 & Tests correct visual indication of stock levels & Functional \\
	\hline
\end{longtable}